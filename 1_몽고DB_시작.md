## 1.몽고DB 소개

먼저 몽고 DB의 주요한 디자인 철학에 대해서 알아보자.

### 손쉬운 사용

몽고 DB는 도큐먼트 지향 데이터베이스로, 빠르고 유연한 확장을 지원한다.  
도큐먼트는 내부 값으로 내장 도큐먼트, 배열을 사용할 수 있기 때문에, 복잡한 계층 구조를 그대로 저장할 수 있다.  
이를 통해 실제 프로그래밍에서 사용하는 객체와 유사한 구조로 데이터를 저장할 수 있다.    
또한 도큐먼트에는 고정된 스키마가 없기 때문에 자유롭게 필드를 추가 및 제거할 수 있다.

### 확장 가능한 설계

몽고 DB는 분산 확장(scale out)을 염두에 두고 설계되었다.  
분산 확장은 DB 확장 시 데이터 스토리지의 스펙을 올리는 대신, 더 많은 스토리지에 데이터를 나눠서 저장하는 스케일링 방법이다.  
도큐먼트는 데이터 계층 구조를 그대로 저장하기 때문에 분산 확장에 보다 적합한 구조이다.  
몽고 DB는 여러 대의 서버에 데이터를 분산해서 저장하고, 데이터 조회 시 적절한 서버를 찾아서 라우팅하도록 지원한다.  
관련된 처리를 DB에서 자체적으로 수행하기 때문에, 스케일링 설정에 변동이 생겨도 어플리케이션은 수정하지 않아도 된다.

### 다양한 기능

몽고 DB는 기본 CRUD를 비롯한 DBMS의 기능과 더불어서, 확장된 기능들을 추가 제공한다.  
먼저 몽고 DB는 보조 인덱싱을 지원하여, 기본적인 unique, compound 인덱싱을 지원한다.  
여기에 추가적으로 도큐먼트의 특성에 맞게 공간 정보, full text, nested document에 대한 인덱싱도 지원한다.  
또한 데이터 처리 파이프라인에 기반한 최적화된 집계 기능도 지원한다.  
데이터 만료일이 존재하는 데이터에 대해서는 TTL 컬렉션으로 정의하는 것이 가능하며, 기준을 만족하는 일부의 도큐먼트에 인덱싱을 거는 부분 인덱스를 지원한다.  
추가적으로 파일에 대한 저장도 지원하여, 용량이 큰 파일 및 파일 메타 데이터 저장이 가능하다.

### 고성능

몽고 DB는 고성능을 유지할 수 있도록 설계되었다.  
성능에 영향을 미칠 수 있는 작업들의 경우 서버에서 수행하지 않고, 클라이언트에 오프로드 된다.  
이를 통해 드라이버 또는 어플리케이션 단에 일부 처리 로직을 위임하여, 서버 단의 성능은 그대로 유지한다.

## 2. 몽고 DB 기본

### 2.1. 도큐먼트

몽고 DB는 키와 값의 쌍으로 이루어진 도큐먼트로 데이터를 저장한다.  
`{"greeting" : "Hello, world!", "views" : 3}`  
값으로 단순히 문자열(blob) 타입이 아닌, 정수 등의 데이터형을 저장할 수 있다.  
각 키는 문자열로 구성되며, 서로 중복되지 않는 유일한 값이어야 한다.

### 2.2. 컬렉션

컬렉션은 도큐먼트의 모음으로, RDB의 테이블과 유사한 개념이다.  

#### 2.2.1 동적 스키마

컬렉션의 가장 큰 특징은 동적 스키마를 지원한다는 것이다.  
몽고 DB에서는 컬렉션 내에 다양한 형태의 도큐먼트를 저장할 수 있도록 허용한다.  
예를 들어 다음의 도큐먼트들이 하나의 컬렉션에 있어도 문제가 되지 않는다.

```js
{"greeting" : "Hello, world!", "views": 3}
{"signoff”: "Good night, and good luck"}
```

하지만 하나의 컬렉션에 완전히 상이한 스키마의 도큐먼트들이 함께 존재하면, 관리하기가 어려워진다.  
또한 상이한 데이터를 하나의 컬렉션에서 관리하기 위해서는 type과 같은 키를 두고 도큐먼트를 구분해야 한다.  
이 때 조회 시에 type으로 쿼리 조건을 줘야 하는데, 단일한 컬렉션에서 조건 없이 조회하는 것에 비해 성능이 저하된다.  
하드웨어 관점에서도 컬렉션으로 구분했을 때 데이터 지역성이 올라가기 때문에, 디스크 탐색 속도를 높이기 위해서는 상이한 데이터는 컬렉션으로 구분해야 한다.  
추가적으로, 인덱싱을 사용하기 위해서도 동일한 데이터 구조를 가져야 한다.  
몽고 DB의 document validation 기능이나, 어플리케이션 단의 object-document mapping 라이브러리를 사용하면 고정된 스키마를 적용할 수 있다.

#### 2.2.2. 네이밍

각 도큐먼트는 문자열로 구성된 이름으로 구분한다.  
몽고 DB에서는 네임스페이스에 .을 붙여서 `blog.posts`, `blog.authors` 등의 이름으로 서브컬렉션을 구성하는 것도 가능하다.  
다만 이는 체계화를 위한 것으로, 컬렉션 간 물리적인 위계 구조를 가지게 되지는 않는다.  
위 예시에서도 `blog` 컬렉션과 `blog.posts` 컬렉션 간 아무런 관계가 없고, 심지어 `blog` 컬렉션은 존재하지 않아도 된다.

### 2.3. 데이터베이스

복수 개의 컬렉션은 데이터베이스로 묶는 것이 가능하다.  
몽고 DB의 단일 인스턴스는 여러 개의 데이터베이스를 호스팅할 수 있다.  
이를 통해 사용자 유형에 따라, 또는 어플리케이션에 따라 데이터베이스를 나누는 것이 가능하다.

데이터베이스는 마찬가지로 이름으로 식별된다.  
admin, local, config는 특수한 의미를 가지는 데이터베이스로, 추후에 자세히 배울 것이다.  
데이터베이스 이름 뒤에 .과 함께 컬렉션 이름을 붙이는 식으로 각 컬렉션의 네임스페이스가 구성된다.  
ex) `cms` 데이터베이스의 `blog.posts` 컬렉션 => `cms.blog.posts`

### 2.4. 몽고DB 시작

유닉스 커맨드라인에서 `mongod` 명령어를 통해 몽고DB를 시작할 수 있다.  
이 때 기본 데이터 디렉터리로 /data/db를 사용하고, 27017 포트에서 소켓 연결을 받는다.

### 2.5 몽고DB 셸 소개

몽고 셸(mongo)를 이용하면 자바스크립트 셸으로 몽고DB 인스턴스와 상호 작용할 수 있다.  
임의의 자바스크립트 코드를 실행하거나, 표준 라이브러리를 사용할 수 있다.

셸은 몽고DB 클라이언트로 사용된다.  
셸은 초기에 test 데이터베이스에 연결한 뒤 글로벌 변수인 db에 데이터베이스 커넥션을 저장한다.  
이를 통해 다음과 같이 컬렉션에 접근하는게 가능하다.

```
> db.movies
```

컬렉션 네임스페이스의 insertOne 등의 메서드를 실행하여 데이터 CRUD 작업을 수행할 수 있다.

```java
db.movies.insertOne(movie)
db.movies.find().pretty()
db.movies.findOne()
db.movies.updateOne(
    {title : "Star Wars"}, 
    {$set : {reviews: []}}
)
db.movies.deleteOne({title : "Star Wars"})
```

또한 셸에서는 SQL 셸 사용자에게 친숙한 기능들을 사용할 수 있도록 지원한다.  
예를 들어 다음의 명령어로 video 데이터베이스를 선택하여 사용할 수 있다.

```
> use video
switched to db video
```

### 2.6. 데이터형

몽고DB의 도큐먼트는 자바스크립트의 객체와 개념적으로 유사하며, JSON처럼 키/값의 쌍으로 이루어져 있다.  
데이터형에서도 JSON에서 지원하는 null, boolean, 숫자, 문자열, 배열, 객체(내장 도큐먼트)를 동일하게 지원한다.
여기에 추가해서 날짜, 정규표현식, ObjectId, 이진 데이터, 코드 데이터형을 지원하고 있다.

#### 2.6.2 날짜

몽고DB에 날짜를 저장할 때에는 자바스크립트의 Date를 사용한다.  
새로운 날짜 값을 저장하기 위해서는 반드시 Date의 생성자를 호출(`new Date()`)해서 인스턴스를 생성해야 한다.  
데이터베이스에는 1970년 1월 1일부터의 시간을 1/1000초 단위로 저장하며, 표준 시간대 정보는 저장하지 않는다.  
(셸에는 현재 시간대 정보를 이용하여 표시된다.)

#### 2.6.3 배열

몽고 DB에는 배열을 저장할 수 있으며, 배열에는 서로 다른 데이터형을 값으로 포함시킬 수 있다.  
몽고 DB에서 지원하는 데이터형이면 무엇이든 요소로 가질 수 있으며, 내장 도큐먼트를 가지거나 중첩 배열을 구성하는 것도 가능하다.  
예를 들어 다음과 같이 도큐먼트에 배열을 저장하는 것이 가능하다.  
`{"things" : ["pie", 3.14]}`

몽고DB는 배열을 이해하고, 배열에 대한 작업을 수행하기 위해 내부 요소에 접근할 수 있다는 강점을 가지고 있다.  
따라서 배열에 쿼리를 하거나, 배열의 내용으로 인덱스를 걸거나, 각 요소를 원자적으로 수정/삭제/추가 하는 것이 가능하다.

#### 2.6.4 내장도큐먼트
도큐먼트에는 그 내부에 키와 값의 쌍으로 이루어진 내장 도큐먼트를 값으로 가질 수 있다.  
이를 통해 데이터를 보다 자유롭게 표현할 수 있다.

```json
{
    "name" : "John Doe",
    "address" : {
        "street" : "123 Park Street",
        "city" : "Anytown",
        "state" : "NY"
    }
}
```

몽고DB는 내장 도큐먼트를 이해할 수 있기 때문에, 내장 도큐먼트의 값으로 인덱싱을 걸거나, 각 요소를 쿼리하거나 수정할 수 있다.  
RDB에서는 위와 같은 구조를 나타내기 위해 people 테이블과 address 테이블을 별도로 정의하고 JOIN해서 사용했을 것이다.  
이와 달리 몽고DB에서는 도큐먼트에서 직접 다른 도큐먼트를 내장하도록 구성할 수 있다.  
다만 내장 도큐먼트로 구성할 경우, 데이터 중복이 발생하여 관리가 어려워질 수 있다.  
예를 들어 여러 개의 people 도큐먼트에서 공통의 address를 사용한다면, 하나의 address를 수정하기 위해 모든 people 도큐먼트를 수정해야 한다.

### _id 와 Objectld

몽고DB의 도큐먼트들은 모두 _id 값을 가진다.  
_id는 하나의 컬렉션 내에서 각 도큐먼트를 고유하게 식별하는 값이다.

도큐먼트 insert 시 _id 값을 지정하지 않으면, 시스템에서 자동으로 생성한 ObjectId를 저장한다.  
ObjectId는 몽고DB가 가진 분산 스토리지의 성격에 맞게, 여러 장비에 샤딩된 환경에서도 고유한 식별자를 갖도록 설계되었다.  

ObjectId는 12바이트의 스토리지를 사용하여, 24자리의 16진수로 표현된다.  
첫 4바이트는 1970년 1월 1일부터의 시간을 1/1000초 단위로 저장하는 타임스탬프이다.  
해당 값을 이용하여 도큐먼트가 생성된 타임스탬프를 역산하는 것도 가능하다.  
타임스탬프 값이 맨 앞자리에 나오기 때문에, ObjectId로 도큐먼트를 정렬하면 데이터 입력 순서대로 정렬이 된다는 장점이 있다.

그 뒤의 5바이트는 랜덤값이 삽입되며, 앞의 4바이트외 함께 묶여서 초 단위의 유일성을 보장해준다.  
마지막 3바이트는 각 시스템에서 랜덤값으로 시작한 단순 증분값으로, 1초 내 단일 프로세스 단위의 유일성을 보장한다.

### 2.7.몽고DB 셸 사용

몽고DB 셸은 로컬의 DB 인스턴스 뿐만 아니라, 원격에 있는 인스턴스에도 연결할 수 있다.
mongod를 실행할 때 호스트명, 포트, 데이터베이스를 명시하면 된다.

```
$ mongo some-host:30000/myDB
```

만약 셸 실행 시 어떤 데이터베이스에도 연결되지 않길 원한다면 一nodb 옵션을 주고 셸을 실행하면 된다.  
이후에 원하는 때에 `new Mongo（호스트명）`를 통해 데이터베이스에 연결한다.

```
$ mongo --nodb
> conn = new Mongo("some-host:30000")
> db = conn.getDB("myDB")
```

### 2.7.1 셸 활용 팁

몽고DB 셸은 기본적으로 자바스크립트 셸로 동작한다.  
셸에 내장된 도움말을 확인하고 싶다면 help를 입력하고, 특정 함수의 소스 코드를 확인하고 싶다면 호출 없이 함수를 입력하면 된다.

```
> db.movies.updateOne
```

### 2.7.2 셸에서 스크립트 실행하기

셸에서는 interactive 하게 명령어를 입력하는 것 외에도, 스크립트를 실행하는 것도 가능하다.

```
$ mongo script1.js
```

대화형 셀에 접근한 뒤에도 load를 통해 스크립트를 실행하는 것도 가능하다.

```
> load("scriptl.js")
```

스크립트 내에서는 전역 변수인 db에 접근하는 것이 가능하다.  
다만 `use database`, `show collections` 와 같은 helper 명령어들은 사용할 수 없다.

스크립트에서 변수를 정의하고, 이를 대화형 셸에서 사용하는 것도 가능하다.  
예를 들어 다음과 같이 connectTo를 스크립트에서 정의하고, 이를 실행하면 셸에서 connectTo 함수에 접근하고 호출할 수 있다.

```js
// script1.js
var connectTo = function(port, dbname) {
    if (!port) {
        port = 27017;
    }
    if (!dbname) {
        dbname = "test";
    }
    db = connect("localhost:"+port+"/"+dbname);
    return db;
}；
```

```
> load('defineConnectTo.j s')
> typeof connectTo
function
```

셸은 기본적으로 셸을 시작한 디렉토리에서 스크립트를 찾는다.  
그 외의 디렉토리에 위치한 파일에 접근해야 한다면, 파일의 절대 경로 또는 상대 경로를 지정할 수 있다.  
`load("/home/myUser/my-scripts/defineConnectTo.js"）`

### 2.7.3 .mongorc.js 만들기

셸을 시작할 때마다 특정 스크립트가 실행되게 하고 싶다면 홈 디렉토리의 .mongorc.js에 스크립트를 작성하면 된다.  
셸에서 사용할 전역 변수를 정의하거나, 내장 함수를 재정의 하는 등의 작업이 가능하다.  
보통은 dropDatabase나 deletelndexes 같은 위험한 함수가 작동하지 않게끔 재정의하는 경우가 많다.

```js
// 데이터베이스 삭제 방지
db.dropDatabase = DB.prototype.dropDatabase = no;
// 컬렉션 삭제 방지
DBCollection.prototype.drop = no;
// 인덱스 삭제 방지
DBCollection.prototype.dropindex = no;
// 인덱스 삭제 방지
DBCollection.prototype.dropindexes = no;
```

### 2.7.4 프롬프트 커스터마이징하기











