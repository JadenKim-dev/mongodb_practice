## 4.1. find 소개

find 함수를 통해 컬렉션의 전체 도큐먼트의 subset을 쿼리할 수 있다.  
첫번째 매개변수의 키/값의 쌍을 통해 어떤 도큐먼트를 조회할지에 대한 기준을 지정한다.  
여러 개의 키/값 쌍을 지정하면 AND로 묶여서 동시에 여러 조건을 적용할 수 있다.

```js
> db.users.find({"username": "joe", "age" : 27})
```

빈 도큐먼트 {}를 매개변수로 넘기면 전체 도큐먼트를 조회하고, 인자로 아무 값을 넘기지 않으면 {}를 넘긴 것처럼 동작한다.

```js
> db.users.find（{}）
> db.users.find（）
```

### 4.1.1 반환받을 키 지정

데이터 조회 시 전체 도큐먼트가 아닌 일부의 키/값만 조회하는 것도 가능하다.  
find의 두번째 인자로 조회하고 싶은 키에 1을 지정해서 넘겨주면 된다.  
이 때 _id는 기본으로 포함되어 조회된다.

```js
> db.users.find({}, {"username" : 1, "email" : 1})
{
    "_id" : Objectld("xxxxx"),
    "username" : "joe",
    "email" : "joe@example.com"
}
```

만약 특정 키를 제외하고 조회하고 싶다면 값에 0을 지정해서 넘겨주면 된다.  
이를 통해 _id도 반환되는 데이터에서 제외할 수 있다.

```js
> db.users.find({}, {"username" : 0, "_id" : 0})
{
    "email" : "joe@example.com",
    "phone_number": "010-1234-5678"
}
```

### 4.1.2 제약사항

쿼리 도큐먼트에서는 상수만 사용 가능하기 때문에, 도큐먼트 내의 다른 키 값을 참조해서 쿼리를 구성하는 것은 불가능하다.  
예를 들어 재고 수량 in_stock과 판매 수량 num_sold가 한 도큐먼트가 있을 때, 재고가 모두 떨어졌는지를 아래와 같이 확인하는 것은 불가능하다.

```js
> db.stock.find({"in_stock" : "this.num_sold"})
```

$where 쿼리 등을 이용하면 되긴 하지만, 가능하다면 상수로 쿼리할 수 있도록 도큐먼트 구조를 재구성해야 성능에 유리하다.  
위 예시에서는 판매가 발생할 때마다 재고 수랑 in_stock을 감소시키는 식으로 구성하면, 해당 값이 0인지를 확인히는 조회 쿼리를 작성하면 된다.

```js
> db.stock.find({"in_stock" : 0})
```

## 4.2 쿼리 조건

몽고DB 쿼리에서는 exact match 조건 외에도 범위 조건, 부정 조건, OR 절 등을 사용하는 것이 가능하다.

### 4.2.1 쿼리 조건절

<, <=, >, >= 는 각각 "$lt", "$lte", "$gt", "$gte" 에 매칭된다.  
여러 조건을 조합하여 특정 범위 내의 값으로 쿼리 대상을 제한할 수 있다.

```js
> db.users.find({"age" : {"$gte" : 18, "$lte" : 30}})
```

날짜 값에 대해서도 동일한 방식으로 쿼리할 수 있다.

```js
> db.users.find({"registered" : {"$lt" : new Date("01/01/2007")}})
```

키 값이 특정 값과 일치하지 않는 데이터를 쿼리하고 싶을 때에는 $ne를 이용하면 된다.  
$ne는 모든 데이터형에 사용 가능하다.

```js
> db.users.find({"username" : {"$ne" : "joe"}})
```

### 4.2.2 OR 쿼리

몽고 DB에서 OR 쿼리를 구성할 때에는 $in 또는 $or를 사용한다.  
먼저 $in은 하나의 키가 여러 값들 중 하나인 도큐먼트를 쿼리한다.

```js
db.raffle.find({"ticket_no" : {"$in" : [725, 542, 390]}})
```

$nin은 반대로 하나의 키가 여러 값들에 해당하지 않는 도큐먼트를 쿼리한다.

db.raffle.find({"ticket_no" : {"$nin" : [725, 542, 390]}})

$or은 여러 키들에 대한 다양한 조건들을 or 로 묶을 때 사용한다.  
$or은 배열에 다른 조건절도 포함할 수 있다.  
예를 들어 티켓 숫자가 특정 값들 중 하나이거나, winner 값이 true인 도큐먼트를 다음괴 같이 조회할 수 있다.

```js
db.raffle.find(
    {"$or" : [
        {"ticket_no" : {"$in" : [725, 542, 390]}},
        {"winner" : true}
    ]}
)
```

$or로도 하나의 키에 대한 여러 조건을 지정 가능하다.  
다만 $in이 좀 더 효율적으로 동작하므로, 하나의 키에 대한 조건은 가능한 $in을 사용해서 구성하자.

### 4.2.3 $not

$not은 다른 조건절과 함께 조합해서 사용하는 메타 조건절이다.  
예제에서는 $mod 조건절과 함께 사용해서 동작 방식을 확인해보자.  
$mod는 해당하는 몫으로 나눈 나머지가 일치하는 도큐먼트를 쿼리한다.  
예를 들어 다음의 쿼리는 id_num이 1, 6, 11, 16 등의 값인 도큐먼트를 쿼리한다.

```js
> db.users.find（{"id_num" : {"$mod" : [5, 1]}}）
```

이 때 만약 조건과 일치하지 않는 2, 3, 4, 5 등의 값을 가진 도큐먼트를 쿼리하고 싶다면 $not과 함께 조합해서 사용하면 된다.

```js
> db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
```

## 4.3 type specific 쿼리

일부 쿼리의 경우 특정 데이터형에만 적용이 가능하다.

### 4.3.1 null

null은 데이터 값이 null 이거나, 아무 값도 할당 되지 않은 경우를 모두 쿼리한다.

```js
> db.c.find()
{ "_id" : ObjectId("xxxx"), "y" : null }
{ "_id" : ObjectId("xxxx"), "y" : 1 }
{ "_id" : ObjectId("xxxx") }

> db.c.find({"y" : null})
{ "_id" : ObjectId("xxxx"), "y" : null }
{ "_id" : ObjectId("xxxx") }
```

만약 값이 null인 도큐먼트만 쿼리하고 싶다면 $exists 조건절을 함께 사용해야 한다.

```js
> db.c.find({"z" : {"$eq" : null, "$exists" : true}})
```

### 4.3.2 정규 표현식

$regex는 정규표현식의 패턴에 일치하는 문자열을 쿼리한다.  

```js
> db.users.find({"name" : {"$regex" : /joe/i}})
```

정규 표현식 플래그(i)는 필요할 때만 지정하면 된다.  
또한 $regex는 생략이 가능하여 일치 조건인 경우 처럼 간결하게 작성할 수 있다.

```js
> db.users.find({"name": /joe/})
```

### 4.3.3 배열에 쿼리하기

특정 값이 배열에 포함되었는지를 쿼리할 때에는 일반 스칼라 쿼리와 동일한 방식으로 작성할 수 있다.

```js
> db.food.insertOne({"fruit" : ["apple", "banana", "peach"]})
> db.food.find({"fruit" : "banana"})
{ _id: ObjectId("xxxx"), "fruit" : ["apple", "banana", "peach"] }
```

이 때 도큐먼트가 다음과 같이 구성되었다고 이해하면 좋다.

```js
{"fruit" : "apple", "fruit" : "banana", "fruit" : "peach"}
```

#### $all 연산자

2개 이상의 배열 요소가 일치하는 도큐먼트를 쿼리할 때에는 $all을 사용한다.  
이 때 요소의 순서와 상관 없이 요소의 일치 여부만을 확인한다.

```js
> db.food.find()
{"_id" : 1, "fruit" : ["apple", "banana", "peach"]}
{"_id" : 2, "fruit" : ["apple", "kumquat", "orange"]}
{"_id" : 3, "fruit" : ["cherry", "banana", "apple"]}

> db.food.find({fruit : {$all : ["apple", "banana"]}})
{"_id" : 1, "fruit" : ["apple", "banana", "peach"]}
{"_id" : 3, "fruit" : ["cherry", "banana", "apple"]}
```

만약 $all 없이 배열로 직접 스칼라 쿼리를 하면, 배열이 정확히 일치하는지를 확인한다.

```js
> db.food.find({"fruit" : ["apple", "banana", "peach"]})
```

배열의 특정 인덱스의 요소를 정확하게 쿼리하고 싶다면 `key.index` 구문으로 인덱스를 지정하면 된다.

```js
> db.food.find({"fruit.2" : "peach"})
```

#### $size 연산자

$size는 특정 크기의 배열을 쿼리하는 연산자이다.  
예를 들어 fruit 배열의 크기가 3인 도큐먼트를 다음과 같이 쿼리할 수 있다.

```js
> db.food.find({"fruit" : {"$size" : 3}})
```

다만 $size는 $gt 등의 다른 조건절과 직접 조합해서 사용할 수 없다.  
원한다면 배열의 크기를 별도의 컬럼으로 함께 관리해야 한다.

#### $slice 연산자

조회 쿼리의 select 절에 $slice 연산자를 사용하면 배열 필드의 부분집합을 조회할 수 있다.  
예를 들어 다음의 쿼리로 comments 배열의 첫 10개의 요소만 한정해서 조회할 수 있다.

```js
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : 10}})
```

만약 마지막 10개 요소만 조회하고 싶다면 -10으로 음수로 지정하면 된다.
또한 $slice는 offset과 요소 개수를 함께 지정해서 특정 범위의 요소를 쿼리하는 것이 가능하다.
예를 들어 다음의 쿼리는 comments 배열의 24번째 요소에서 33번째 요소까지 총 10개를 쿼리한다.

> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}})

$slice는 select 절에 사용되는 다른 specifier와 다르게, 다른 키 값들을 배제하지 않는다.  
지금까지 작성해온 쿼리들도 도큐먼트 내에 comments 외에 다른 키가 있다면 해당 키를 함께 조회한다.

```js
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : -1}})
{
    "_id" : ObjectId("xxxx"),
    "title" : "A blog post",
    "comments" : [
        {
            "name" : "bob",
            "email" : "bob@example.com",
            "content" : "good post."
        }
    ]
}
```

#### 일치하는 배열 요소의 반환

특정 조건을 만족하는 배열의 요소를 조회하고 싶다면 $ 연산자를 사용할 수 있다.













