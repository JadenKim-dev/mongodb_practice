## 5.1 인덱싱 소개

데이터 베이스에서 데이터를 정렬하여 조회할 때에는 인덱스를 이용해서 조회 성능을 개선하는 경우가 많다.  
만약 인덱스를 사용하지 않고 쿼리를 하면 컬렉션 스캔이 발생하여, 쿼리 결과를 얻기 위해 모든 데이터를 살펴봐야 한다.   
컬렉션 크기가 커질수록 컬렉션 스캔에 걸리는 시간도 함께 비례해서 증가한다.

몽고DB 쿼리 시 커서 보조자 메서드인 explain을 함께 사용하면, 쿼리 과정에서 수행한 작업의 정보를 확인할 수 있다.  
executionStats 모드로 호출하면 쿼리 과정에서 살펴본 도큐먼트 수, 조회된 데이터 수 등을 확인할 수 있다.

```js
> db.users.find({"username": "user101"}).explain("executionStats")
{
    ...
    "executionStats" : {
        "executionSuccess" : true,
        "nReturned" : 1,
        "executionTimeMillis" : 419,
        "totalKeysExamined" : 0,
        "totalDocsExamined" : 1000000,
        ...
    }
}
```

각 항목을 살펴보면 전체 결과는 1개임에도 불구하고, 총 100만 개의 전체 데이터를 모두 살펴본 것을 알 수 있다.  
몽고 DB는 username 필드가 고유한 값이라는 것을 모르기 때문에 전체 도큐먼트를 살펴본 것이다.

몽고DB가 쿼리를 효율적으로 실행하도록 하기 위해서는, 모든 쿼리 패턴에 인덱스를 적용해야 한다.  
쿼리 패턴은 어플리케이션에서 DB에 전달하는 쿼리 유형을 말한다.

### 5.1.1 인덱스 생성

인덱스를 생성할 때에는 컬렉션의 createIndex 메서드를 사용한다.

```js
> db.users.createIndex({"username" : 1})
```

이제 위에서 실행했던 쿼리를 다시 실행해보면, 1개의 도큐먼트를 살펴본 것만으로 쿼리 실행이 완료된 것을 확인할 수 있다.  
실행 시간을 확인해보면 거의 즉각적으로 쿼리가 완료되었다.

```js
> db.users.find({"username": "user101"}).explain("executionStats")
{
    ...
    "executionStats" : {
        "executionsuccess" : true,
        "nReturned" : 1,
        "executionTimeMillis" : 1,
        "totalKeysExamined" : 1,
        "totalDocsExamined" : 1,
        ...
    }
}
```

이와 같이 인덱스를 생성하면 조회에서는 매우 큰 성능 향상을 보인다.  
하지만 데이터 삽입, 수정, 삭제 시에는 매번 인덱스를 새롭게 설정해야 하기 때문에 더 느려진다.  
따라서 수정이 잦은 필드인지 조회가 잦은 필드인지를 파악하고 인덱스를 설정해야 한다.

### 5.1.2 복합 인덱스 소개

위에서는 단일한 키에 인덱스를 걸어서, 단일 키 쿼리의 실행 시간을 단축시켰다.  
하지만 많은 경우 쿼리 패턴에서는 여러 개의 키를 사용한다.  
이 때 인덱스가 일부의 키에만 적용되어 있다면, 쿼리 순서에 따라서 성능 개선 효과가 제한적이다.  
예를 들어 username에만 인덱스가 적용된 상태에서 다음의 쿼리를 실행한다고 하자.

```js
> db.users.find().sort({"age" : 1, "username" : 1})
```

해당 쿼리의 경우 먼저 age로 정렬한 후 username으로 정렬한다.  
인덱스가 적용된 username이 쿼리 패턴의 앞에 나왔으면 괜찮았겠지만, 뒤에 나오면 전혀 도움이 되지 않는다.

위 정렬 쿼리를 최적화하기 위해서는 age, username을 이용하여 복합 인덱스를 생성해야 한다.  

```js
> db.users.createIndex({"age" : 1, "username" : 1})
```

복합 인덱스는 검색 키가 여러 개이거나 정렬 방향이 여러 개일 때 사용할 수 있다.  
복합 인덱스를 구성하면 각 인덱스 항목([age, username])이 레코드 식별자를 가리키는 형태로 인덱스가 생성된다.  
스토리지 엔진에서는 레코드 식별자를 이용하여 빠르게 도큐먼트를 찾을 수 있다.

```
[0, "user100020"] -> 8623513776
[0, "user1002"] -> 8599246768
...
[0, "user100414"] -> 8623564208
[1, "user100113"] -> 8623525680
[1, "user100280"] -> 8623547056
...
[1, "user100626"] -> 8623591344
[2, "user100191"] -> 8623535664
[2, "user100195"] -> 8623536176
...
```

이렇게 인덱스가 구성된 상태에서 각 쿼리가 어떻게 동직하는지 알아보자.  
먼저 age 동등 조건으로 필터링 하고 username으로 정렬을 수행하는 쿼리이다.

```js
> db.users.find({"age" : 21}).sort({"username" : -1})
```

몽고DB에서는 `{"age" : 21}` 조건과 일치하는 데이터들을 마지막 항목부터 역순으로 탐색한다.  
인덱스의 첫번째 키(age)를 통해 바로 원하는 데이터로 이동하고, 인덱스의 두 번째 키로 이미 데이터가 적절히 정렬되어 있기 때문에 쿼리가 효율적으로 동작한다. 

이번에는 age 범위 조건으로 필터링하는 쿼리를 살펴보자.

```js
> db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})
```

이 경우 인덱스의 첫번째 키인 age를 이용해 적절한 데이터 목록을 찾아서 반환받는다.  
데이터 조회시 인덱스를 사용하므로 인덱스 순서에 따라 도큐먼트를 받게 된다.

```
[21, "user100154"] -> 8623530928
[21, "user100266"] -> 8623545264
...
[21, "user999600"] -> 8765277104
[22, "user100017"] -> 8623513392
...
[29, "user999861"] -> 8765310512
[30, "user100098"] -> 8623523760
[30, "user100155"] -> 8623531056
...
```

이번에는 age 범위 필터와 함께 username 정렬을 적용한 경우를 살펴보자.

```js
db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})
```

위에서 살펴봤듯이 인덱스는 `{"age" : 1, "username" : 1}`으로 정렬된 결과를 반환한다.  
쿼리에서는 username으로 정렬된 결과를 요청했으므로, 몽고DB에서는 인메모리에서 정렬을 수행하게 되어 성능이 저하된다.

이 때 만약 `{"username" : 1, "age" : 1}`으로 인덱스를 적용했다면 어떻게 동작할까?  
몽고DB에서는 원하는 결과를 얻기 위해 모든 데이터를 탐색해야 하지만, 인메모리 정렬 없이도 원하는 순서대로 정렬된 데이터를 얻게 된다.  

```
[user100000, 21] -> 8623511216
[user100003, 27] -> 8623511600
[user100004, 22] -> 8623511728
...
```

복합 인덱스 구성 시에는 인메모리 정렬을 피하기 위해 정렬 기준 키를 첫번째 인덱스로 두는 것이 좋다.

### 5.1.3 몽고DB가 인덱스를 선택하는 방법

몽고DB는 쿼리를 요청받으면 필터 및 정렬 조건을 구성하고 있는 쿼리 모양을 확인하고, 이를 기반으로 인덱스 후보들을 선정한다.  
각 인덱스 후보들로 쿼리 플랜이 구성되며, 병렬 쓰레드에서 각 플랜이 개별적으로 실행된다.  
이렇게 모든 플랜이 한 번씩 실행 되는 것으로 히나의 레이스가 구성되고, 각 레이스에서 어떤 플랜이 가장 먼저 목표 상태에 도달했는지를 확인한다.  
가장 먼저 쿼리의 전체 결과를 반환하거나, 대상 목록의 정렬된 결과를 반환하면 승자가 된다.  

레이스는 trial period 동안 수차례 실행되며, 가장 많이 승리한 플랜이 해당 쿼리 모양의 플렌으로 선정된다.  
승리한 플랜은 캐시에 저장되어 이후에 동일한 쿼리 모양이 요청되었을 때 자동으로 사용된다.  
컬렉션이 수정되거나 인덱스가 추가/수정/삭제되면 캐시에서 플랜이 삭제되며, 레이스를 통해 새로운 플랜을 선정한다.

### 5.1.4 복합 인덱스 사용

인덱스를 구성할 때에는 가능한 쿼리가 효율적으로 동작할 수 있도록 해야 한다.  
이를 위해서 몇 가지 원칙들을 고려해야 하고, 실제 워크로드에서 인덱스를 테스트하고 조정하는 것이 좋다.

먼저 인덱스의 선택성을 고려해야 한다.  
인덱스를 구성할 때에는 특정 쿼리 패턴에서 레코드 스캔이 얼마나 최소화되는지를 확인해야 한다.  
예를 들어 다음과 같은 도큐먼트의 인덱스를 구성한다고 하자.

```js
{
    "_id" : ObjectId("xxx"),
    "student_id" : 0,
    "scores" : [
        {
            "type" : "exam",
            "score" : 38.05000060199827
        },
        {
            "type" : "quiz",
            "score" : 79.45079445008987
        }
    ],
    "class_id" : 127
}
```

해당 컬렉션에 대해서 다음의 두 인덱스를 생성했다고 하자.

```js
> db.students.createIndex({class_id: 1})
> db.students.createIndex({student_id: 1, class_id: 1})
```

이제 student_id 범위 조건, class_id 동등 조건으로 결과를 제한하고, student_id로 정렬을 수행하는 다음의 쿼리를 실행해보자.  
이 때 `explain("executionStats")`를 추가로 실행하여 쿼리 실행 정보를 함께 확인한다.

```js
> db.students.find({student_id:{$gt:500000}, class_id:54})
    .sort({student_id:1})
    .explain("executionStats")
{
    ...
    "executionStats"： {
        "executionSuccess": true,
        "nReturned": 9903,
        "executionTimeMillis": 4325,
        "totalKeysExamined": 850477,
        "totalDocsExamined": 9903,
        ...
    }
}
```

executionStats 정보를 통해 총 9903개의 결과를 반환받기 위해 인덱스 키 850477개를 살펴본 것으로 확인할 수 있다.  
이는 인덱스가 선택적으로 작동하지 못했음을 의미하고, 이로 인해 총 실행 시간도 4.325초가 걸렸다.

winningPlan 항목에서는 어떤 인덱스의 플랜이 레이스에서 승리하여 사용되었는지를 확인할 수 있다.  
예제에서는 student_id, class_id로 구성된 복합인덱스가 선택되었다.

```js
{
    "winningPlan": {
        "stage": "FETCH",
        "inputstage": {
        "stage": "IXSCAN",
        "keyPattern": {
            "student_id": 1,
            "class_id": 1
        }
    }
}
```

쿼리 플랜은 위와 같이 각각의 stage로 표현된다.  
예제에서는 입력 단계인 인덱스 스캔(IXSCAN)을 수행하여, 쿼리와 일치하는 인덱스의 레코드 ID를 상위 단계인 FETCH에 전달했다.  
FETCH에서는 해당 레코드 ID로 도큐먼트를 조회하여 클라이언트에 반환한다.  
승리 플랜에서는 인덱스 스캔만으로 정렬된 결과를 얻는데 성공하여 추가적인 인메모리 정렬이 발생하지 않았다.

실패한 쿼리는 rejectedPlans 항목에서 확인한다.  
이 때 실패 플랜에서는 인덱스 사용에 실패해서 인메모리 정렬(SORT)이 발생했다.

```js
{
    "rejectedPlans": [
        {
            "stage": "SORT",
            "sortPattern": {
                "student_id": 1
            },
        }
    ]
}
```

예제에서는 복합 인덱스를 사용했으나 성능 향상이 제한적이었다.  
이는 student_id를 이용한 범위 조건이 낮은 선택성을 가지기 때문이다.  
student_id가 50000보다 큰 조건을 만족하는 도큐먼트는 85만개로 매우 많다.  
인덱스로 1차적으로 거르더라도, class_id 동등 조건을 추가로 만족하는 데이터를 찾기 위해서는 85만개의 키를 모두 스캔해야 한다.  

사실 해당 쿼리는 레이스에서 실패한 class_id 단일키 인덱스를 사용하는 편이 더 효율적이다.  
만약 쿼리 실행에서 특정 인덱스를 강제하고 싶다면 hint 메서드를 호출하면 된다.  
실행 통계 정보를 확인해보면 스캔한 키 수가 20076, 총 실행 시간이 0.272초로 감소한 것을 확인할 수 있다.

```js
> db.students.find({student_id:{$gt:500000}, class_id:54})
    .sort({student_id:1})
    .hint({class_id:l})
    .explain("executionStats")
{
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 9903,
        "executionTimeMillis": 272,
        "totalKeysExamined": 20076,
        "totalDocsExamined": 20076,
        ...
    }
}
```

다만 이런 식으로 인덱스를 직접 지정하면 slow query를 유발할 수 있다.  
가능하다면 더 효과적으로 작동하는 인덱스를 추가로 등록하여 해당 인덱스가 사용되도록 유도하는 것이 좋다.  
위 예제에서는 동등 필터에 사용되는 class_id를 첫번째 키로, 범위 필터에 사용되는 student_id를 두번째 키로 등록하면 된다.  
해당 인덱스를 등록하고 다시 데이터를 조회해보면 nReturned와 totalDocsExamined 값이 동일하여, 정확히 필요한 데이터만 스캔된 것을 확인할 수 있다.  
이를 통해 쿼리 실행 시간이 0.037초로 크게 줄어들었다.

```js
> db.students.createlndex({class_id:1, student_id:1})
> db.students.find({student_id:{$gt:500000}, class_id:54})
    .sort({student_id:1})
    .explain("executionStats")
{
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 9903,
        "executionTimeMillis": 37,
        "totalKeysExamined": 9903,
        "totalDocsExamined": 9903,
        ...
    }
}
```

이 때에는 다음과 같이 [class_id, student_id] 형태의 키 쌍으로 인덱스가 구성된다.  
각 class_id 별로 student_id가 정렬되어 있으므로, 예제 쿼리에서는 class_id가 54, student_id가 50000인 데이터에서 스캔을 시작하면 된다.

```
...
[53, 999617]
[53, 999780]
[53, 999916]
[54, 500001]
[54, 500009]
[54, 500048]
...
```

위 예제는 쿼리 필터와 정렬에 동일한 키가 사용된 특수 케이스였다.  
복합 인덱스 설계 시에는 동등 필터, 다중값 필터, 정렬을 모두 고려해야 한다.  
이번에는 정렬에 final_grade를 사용하여 필터 키와 정렬 키를 다르게 구성해보자.  
이제 실행 단계에 인메모리 정렬이 포함되고, 쿼리 수행 시간이 0.136초로 증가한 것을 확인할 수 있다.

```js
> db.students.find({student_id:{$gt:500000}, class_id:54})
    .sort({final_grade:1})
    .explain("executionStats")
{
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 9903,
        "executionTimeMillis": 136,
        "totalKeysExamined": 9903,
        "totalDocsExamined": 9903,
        "executionstages": {
            "stage": "SORT",
            ...
        }
}
```

인메모리 정렬을 피하고 싶다면, 인덱스에 정렬 기준 키를 포함해서 생성해야 한다.  
[동등 필터 키, 정렬 키, 다중값 필터 키] 형태로 인덱스를 구성하면 인메모리 정렬 없이 쿼리를 실행할 수 있다.

```js
> db.students.createIndex({class_id:1, final_grade:1, student_id:1})
```

다만 이렇게 구성할 경우 스캔하는 도큐먼트가 많아지는 트레이드 오프가 존제한다.  
이제는 student_id 범위 조건에 맞는 데이터를 걸러내기 위해 class_id 동등 조건에 맞는 데이터를 모두 스캔해야 한다.

```js
> db.students.find({student_id:{$gt:500000}, class_id:54})
    .sort({final_grade:1})
    .explain("executionStats")
{
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 9903,
        "executionTimeMillis": 42,
        "totalKeysExamined": 9905,
        "totalDocsExamined": 9903,
        ...
    }
}
``

지금까지 확인한 내용들을 종합하면 다음의 원칙을 도출해낼 수 있다.  
복합 키 인덱스를 구성할 때에는 해당 원칙들을 지켜서 구성하자.

- 동등 필터 키를 맨 앞에 표시
- 정렬 키는 다중값 필터 키 앞에 표시
- 다중값 필터 키는 마지막에 표시

#### 키 방향 선택하기

지금까지는 인덱스를 구성할 때 모두 오름차순으로 정렬했다.  
몽고DB는 인덱스의 역방향으로도 데이터를 스캔할 수 있으므로, 단일 키로 인덱스를 구성할 경우에는 인덱스의 방향과 무관하게 인덱스를 정렬에 사용할 수 있다.  
하지만 복합키로 구성할 때에는 각 정렬 키의 방향이 정확히 일치하거나, 완전히 역방향이어야 사용할 수 있다.  

```js
> db.students.createIndex({"username" : 1, "age": -1})
> db.users.find({}).sort({"username" : 1, "age": -1})
> db.users.find({}).sort({"username" : -1, "age": 1})

```

#### covered query 사용하기

인덱스를 통해 데이터를 조회하면 인덱스가 가리키는 포인터를 따라가서 도큐먼트를 가져온다.  
하지만 쿼리가 인덱스에 포함된 필드만을 조회하는 커버드 쿼리라면, 도큐먼트 조회 없이 인덱스 키만을 가져온다.

가능하다면 인덱스 안에 조회할 칼럼들이 모두 포함되도록 구성하여 추가로 도큐먼트를 조회하지 않도록 하는 것이 좋다.  
이렇게 하면 FETCH 단계 없이 IXSCAN 단계가 실행되며, totalDocsExamined의 값이 0이 되어 도큐먼트 접근이 아예 없게 된다.  
다만 이를 위해 _id는 반환받지 않도록 지정해야 하며, 인덱스의 키가 늘어날수록 쓰기 작업의 속도가 느려지기 때문에 적절히 조율해서 구성해야 한다.  

#### 암시적 인덱스

복합키 인덱스의 경우 자신의 접두사 모양의 쿼리에는 동일하게 사용할 수 있다.  
예를 들어 `{"a" : 1, "b" : 1, "c" : 1, "d": 1}` 인덱스를 등록했다면, `{"a" : 1}`, `{"a" : 1, "b" : 1}`, `{"a" : 1, "b" : 1, "c" : 1}` 쿼리에서 활용이 가능하다.

### 5.1.5 $연산자의 인덱스 사용법

몽고DB의 쿼리 연산자들은 종류에 따라 인덱스를 잘 활용하기도, 전혀 못하기도 한다.

#### 비효율적인 연산자

일반적으로 부정 조건은 비효율적으로 동작한다.  
$ne는 특정 값을 제외한 나머지 인덱스를 모두 살펴봐야 한다.  
예를 들어 `{"i" : {"$ne" : 3}}` 조건으로 쿼리한다면 3보다 작거나 큰 인덱스를 모두 살펴봐야 한다.

$not은 일부 범위 쿼리($gt, $lt)와 정규표현식에 대해서는 자체적으로 연산자를 뒤집어서 실행하므로 인덱스를 사용하는 것이 가능하다.  
하지만 대부분의 경우 전체 도큐먼트를 스캔하여 부정 조건에 부합하는지를 체크하는 식으로 동작한다.  
$nin은 언제나 전체 도큐먼트를 스캔하여 조건을 확인한다.

반드시 부정조건을 사용해야 하는 상황이라면, 부정 조건 전에 인덱스들을 일부 거를 수 있도록 다른 조건들을 추가해야 한다.

#### 범위

단일한 범위 쿼리($gt, $lt)는 인덱스 적용이 가능하다.  
다만 복합키 인덱스로 구성하는 경우에는 반드시 동등 조건 키가 앞에, 범위 조건 키가 뒤에 위치하도록 구성해야 한다.  
이 원칙을 지키지 않거나, 한 쿼리에 범위 조건을 여러 개 적용하면 비효율적으로 동작한다.

#### OR 쿼리

기본적으로 몽고DB는 쿼리 하나에 하나의 인덱스만 적용할 수 있다.  
예를 들어 `{"x" : 1}`, `{"y" : 1}`로 각각 인덱스를 등록했다면, `{"x" : 123, "y" : 456}` 으로 쿼리 시 하나의 인덱스만 적용받는다.  
다만 $or의 경우 각 절마다 쿼리를 수행하고, 이를 합치는 식으로 동작하기 때문에 각각 인덱스를 적용할 수 있다.  
예를 들어 다음의 쿼리는 `{"x" : 1}`, `{"y" : 1}` 쿼리를 각각 이용하여 쿼리가 실행된다.

```js
> db.foo.find({"$or" : [{"x" : 123}, {"y" : 456}]})
```

하지만 $or는 두 개의 쿼리를 모두 실행해야 하고, 두 결과의 중복을 제거하는 병합 작업을 수행하기 때문에 느리게 작동한다.  
가능하다면 $in을 사용해서 쿼리를 구성하는 것이 좋다.

> $in을 사용하면 결과의 순서가 보장되지 않으므로, 필요하다면 정렬을 수행해야 한다.
> 예를 들어 `{"x" : {"$in" : [1, 2, 3]}}`은 `{"x" : {"$in" : [3, 2, 1]}}과 동일한 결과를 반환한다.

### 5.1.6 객체 및 배열 인덱싱

몽고DB에서는 도큐먼트 내의 내장 도큐먼트와 배열로 인덱스를 구성할 수 있다.  
도큐먼트/배열 키도 다른 키와 함께 복합 키 인덱스로 구성할 수 있으며, 대부분의 경우에 일반적인 인덱스와 동일하게 동작한다.

#### 내장 도큐먼트 인덱싱하기

예를 들어 다음과 같이 사용자의 위치 정보를 내장 도큐먼트 loc으로 저장하는 컬렉션이 있다고 하자.

```json
{
    "username" : "sid",
    "loc" : {
        "ip" : "1.2.3.4",
        "city" : "Springfield",
        "state" : "NY"
    }
}
```

이 때 내장 도큐먼트의 특정 키로 인덱스를 구성할 수 있다.  
다른 키에 인덱스를 지정하는 것과 동일하게 동작하며, `a.b.c.d` 와 같이 중첩되어 있는 필드를 지정하는 것도 가능하다.

```js
> db.users.createIndex({"loc.city" : 1})
```

만약 내장 도큐먼트 자체를 인덱스로 지정하면(`createIndex({"loc" : 1})`) 다소 다르게 동작한다.  
이 때에는 내장 도큐먼트 전체 값을 순서에 맞춰서 쿼리해야 인덱스를 사용할 수 있다.

```js
db.users.find({
    "loc" : {
        "ip" : "123.456.789.000",
        "city" : "Shelbyville",
        "state" : "NY"
    }
})
```

만약 내장 도큐먼트의 일부만 사용하거나, 순서를 다르게 지정하면 인덱스가 사용되지 않는다.

```js
db.users.find({"loc.city" : "Shelbyville"})
```

#### 배열 인덱싱하기

배열도 마찬가지로 인덱싱하는 것이 가능하다.  
다만 배열의 각 요소를 인덱싱하는 식으로 동작하기 때문에, 배열 자체를 통째로 인덱싱 할 수는 없다.  

예를 들어 blog 도큐먼트의 comments 배열에 내장 도큐먼트로 댓글 정보가 들어있다고 하자.  
이 때 최근 댓글 순으로 정렬을 해야 한다면, chats.date에 인덱스를 지정할 수 있다.

```js
> db.blog.createIndex({"comments.date" : 1})
```

이렇게 인덱스를 생성할 경우 comments 배열의 모든 내장 도큐먼트에 대해서 인덱스가 생성된다.  
만약 comments에 20개의 객체가 포함된 경우, 한 도큐먼트에 20개의 인덱스가 만들어진다.  
이로 인해 인덱스 개수가 지나치게 많아져 데이터 추가, 수정, 삭제 작업이 느려질 수 있다.

배열의 인덱스에는 위치 개념이 없기 때문에, 위와 같이 인덱스를 등록하면 `comments.4`와 같이 특정 요소를 쿼리할 때에는 인덱스를 사용할 수 없다.  
배열의 특정 항목에 인덱스를 설정하는 것도 가능하지만, 배열의 해당 항목을 쿼리할 때에만 한정적으로 사용된다.

```js
> db.blog.createIndex({"comments.10.vote": 1})
```

또한 각 도큐먼트에 대해서는 한 필드에만 배열 인덱싱을 적용할 수 있다.  
예를 들어 `{"x" : 1, "y" : 1}` 인덱스가 적용된 컬렉션의 경우 `{"x" : [1, 2, 3], "y" : [4, 5, 6]}` 형식으로 데이터를 삽입하는 건 불가능하다.  
`{"x" : [1, 2, 3], "y" : 1}`, `{"x" : 1, "y" : [4, 5, 6]}` 처럼 한 필드에만 배열을 지정한 경우에는 삽입이 가능하다.  
이는 `n * m` 식으로 무한히 인덱스가 늘어나는 것을 방지하기 위함이다.

#### Multi Key 인덱스가 미차는 영향

배열 필드를 인덱스 키로 가지면 해당 인덱스는 즉시 Multi Key 인덱스로 인식되며, explain() 출력의 isMultiKey 값이 true가 된다.  
다중키 인덱스는 여러 인덱스가 하나의 도큐먼트를 가리킬 수 있다고 가정하기 때문에, 결과 데이터에 대해서 중복 제거를 수행한다.  
이로 인해 더 느리게 동작하므로 만약 인덱스 키에 배열이 삽입된 도큐먼트가 없어졌다면, 인덱스를 제거한 후 다시 생성하여 단일키 인덱스로 바꾸는 편이 좋다.

### 5.1.7 인덱스 카디널리티

카디널리티는 도큐먼트의 특정 필드가 얼마나 많은 고유값을 가지는지를 의미한다.  
예를 들어 gender와 같이 중복이 많은 필드는 카디널리티가 낮고, email 처럼 데이터마다 값이 다른 필드는 카디널리티가 높다.  

일반적으로 카디널리티가 높은 필드를 인덱스 키로 지정해야 보다 효율적으로 인덱싱이 가능하다.  
복합키 구성 시에도 카디널리티가 높은 필드를 인덱스의 앞부분에 위치시키는 것이 좋다.  
예를 들어 {"gender": 1, "email": 1}로 지정한다면 먼저 한 성별에 해당하는 전체 데이터셋을 살펴봐야 한다.  
이와 달리 {"email": 1, "gender": 1}로 지정하면 먼저 email로 결과셋을 좁힐 수 있다.

## 5.2 explain 출력

explain은 쿼리에 대한 많은 정보를 제공하며, slow query에 대한 진단 도구로 사용된다.  
어떤 쿼리든 뒤에 explain 함수를 이어서 호출하여 쿼리 정보를 확인할 수 있다.

인덱스를 사용하지 않는 쿼리들은 explain 출력이 비슷하다.  
실행 단계에 COLLSCAN이 표시되면 인덱스를 사용하지 않은 것이다.

인덱스를 사용한 경우에는 먼저 queryPlanner.winningPlan 항목에서 어떤 플랜이 선택되었는지, 어떤 인덱스를 사용했는지를 살펴볼 수 있다.  
인덱스를 사용하는 입력 단계는 IXSCAN 으로 표시된다.  
queryPlanner.rejectedPlans에는 실패한 쿼리 플랜들이 나열된다.

```js
> db.users.find({"age" : 42}).explain(’executionStats')
```

```json
"queryPlanner":
    "winningPlan" : {
        "stage" : "FETCH",
        "inputstage" : {
            "stage" : "IXSCAN",
            "keyPattern" : {
                "age" : 1,
                "username" : 1
            },
            "indexName" : "age_1_username_1",
            "isMultiKey" : false,
            ...
        }
    },
    "rejectedPlans" : [ ]
}
```

그 아래에는 다양한 쿼리 실행 정보를 확인할 수 있다.  
nReturned는 최종적으로 반환된 도큐먼트 개수, totalKeysExamined는 검색한 인덱스 개수, totalDocsExamined는 검색한 도큐먼트 개수이다.  
executionTimeMillis는 전체 쿼리 실행 시간을 나타내는데, 여러 개의 쿼리 플랜을 시도했다면 모든 플랜을 실행하는데 걸린 시간이 담긴다.  

executionStages 에서는 각각의 실행 단계에서 수행한 작업 정보를 확인할 수 있다.  
isMultiKey가 false 이므로 다중키 인덱스가 아닌 단일키 인덱스를 사용했음을 알 수 있다.  
위 쿼리에서는 인덱스를 이용해 age의 `[42.0, 42.0]` 경계 내에서 검색했다.

```js
{
    "executionStats" : {
        "executionSuccess" : true,
        "nReturned" : 8449,
        "executionTimeMillis" : 15,
        "totalKeysExamined" : 8449,
        "totalDocsExamined" : 8449,
        "executionStages” : {
            ...
            "inputstage" : {
                "stage" : "IXSCAN",
                "nReturned" : 8449,
                "needYield": 0,
                "isMultiKey" : false,
                "indexBounds” : {
                "age" : [
                    "[42.0, 42.0]"
                ],
                "username" : [
                    "[MinKey, MaxKey]"
                ],
                ...
            }
        }
    }
}
```

> needYield는 쓰기 요청을 처리하도록 양보한 횟수를 의미한다.  
> 몽고 DB에서는 쿼리 과정에서 대기 중인 쓰기 요청이 있는 경우, 잠시 락을 풀어서 쓰기 작업이 수행될 수 있게 한다.

## 5.3 인덱스를 생성하지 않는 경우








