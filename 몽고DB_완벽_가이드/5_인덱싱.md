## 5.1 인덱싱 소개

데이터 베이스에서는 인덱스를 이용해서 데이터를 정렬하여 살펴본다.  
만약 인덱스를 사용하지 않고 쿼리를 하면 컬렉션 스캔이 발생하여, 쿼리 결과를 얻기 위해 모든 데이터를 살펴봐야 한다.   
컬렉션 크기가 커질수록 컬렉션 스캔에 걸리는 시간도 함께 비례해서 증가한다.

몽고DB 쿼리 시 커서 보조자 메서드인 explain을 함께 사용하면, 쿼리 과정에서 수행한 작업의 정보를 확인할 수 있다.  
executionStats 모드로 사용하면 쿼리 과정에서 살펴본 도큐먼트 수, 조회된 데이터 수 등을 확인할 수 있다.

```js
> db.users.find({"username": "user101"}).explain("executionStats")
{
    ...
    "executionStats" : {
        "executionSuccess" : true,
        "nReturned" : 1,
        "executionTimeMillis" : 419,
        "totalKeysExamined" : 0,
        "totalDocsExamined" : 1000000,
        ...
    }
}
```

executionStats 항목을 살펴보면 전체 결과는 1개임에도 불구하고, 총 100만 개의 전체 데이터를 모두 살펴보았다.  
몽고 DB는 username 필드가 고유한 값이라는 것을 모르기 때문에 전체 도큐먼트를 살펴봐야 한다.

몽고DB가 쿼리에 효율적으로 작동하도록 하기 위해서는, 모든 쿼리 패턴에 인덱스를 적용해야 한다.  
쿼리 패턴은 어플리케이션에서 DB에 전달하는 모든 쿼리 유형을 말한다.

### 5.1.1 인덱스 생성

인덱스를 생성할 때에는 컬렉션의 createIndex 메서드를 사용한다.

```js
> db.users.createIndex({"username" : 1})
```

이제 이전에 했던 쿼리를 다시 실행해보면, 1개의 도큐먼트를 살펴본 것만으로 쿼리가 완료된 것을 확인할 수 있다.  
실행 시간을 확인해봐도 거의 즉각적으로 쿼리가 완료되었음을 알 수 있다.

```js
> db.users.find({"username": "user101"}).explain("executionStats")
{
    ...
    "executionStats" : {
        "executionsuccess" : true,
        "nReturned" : 1,
        "executionTimeMillis" : 1,
        "totalKeysExamined" : 1,
        "totalDocsExamined" : 1,
        ...
    }
}
```

이와 같이 인덱스를 생성하면 조회에서는 매우 큰 성능 향상을 보인다.  
하지만 데이터 삽입, 수정, 삭제 시에는 매번 인덱스를 새롭게 설정해줘야 하기 때문에 더 느려진다.  
따라서 수정이 잦은 필드인지 조회가 잦은 필드인지를 파악하고 인덱스를 설정해야 한다.

### 5.1.2 복합 인덱스 소개

위에서는 단일한 키에 인덱스를 걸어서, 해당 키를 기준으로 데이터를 미리 정렬해두도록 구성했다.  
하지만 많은 경우 쿼리 패턴에서는 여러 개의 키를 이용한다.  
이 때 인덱스가 일부의 키에만 적용되어 있다면, 쿼리 순서에 따라서 성능 개선 효과가 제한적일 수 있다.  
예를 들어 username에만 인덱스가 적용된 상태에서 다음의 쿼리를 실행한다고 하자.

```js
> db.users.find().sort({"age" : 1, "username" : 1})
```

해당 쿼리의 경우 먼저 age로 정렬한 후 username으로 정렬한다.  
인덱스가 적용된 username이 쿼리 패턴의 앞에 나왔으면 괜찮았겠지만, 뒤에 나오면 큰 도움이 되지 않는다.

위 정렬 쿼리를 최적화하기 위해서는 age, username을 이용해 복합 인덱스를 생성해야 한다.  

```js
> db.users.createIndex({"age" : 1, "username" : 1})
```

복합 인덱스는 검색 키가 여러 개이거나 정렬 방향이 여러 개일 때 사용할 수 있다.  
복합 인덱스를 구성하면 각 인덱스 항목([age, username])이 레코드 식별자를 가리키는 형태로 인덱스가 생성된다.  
스토리지 엔진에서는 레코드 식별자를 이용하여 빠르게 도큐먼트를 찾을 수 있다.

```
[0, "user100020"] -> 8623513776
[0, "user1002"] -> 8599246768
...
[0, "user100414"] -> 8623564208
[1, "user100113"] -> 8623525680
[1, "user100280"] -> 8623547056
...
[1, "user100626"] -> 8623591344
[2, "user100191"] -> 8623535664
[2, "user100195"] -> 8623536176
...
```

이렇게 인덱스가 구성된 상태에서 각 쿼리가 어떻게 동직하는지 알아보자.  
먼저 username을 이용한 단일한 동일 쿼리를 구성한 경우이다.

```js
> db.users.find({"age" : 21}).sort ({"username" : -1})
```

몽고DB에서는 `{"age" : 21}` 조건과 일치하는 데이터들을 마지막 항목부터 역순으로 탐색한다.  
인덱스의 첫번째 키(age)를 통해 바로 원하는 데이터로 이동하고, 인덱스의 두 번째 키로 이미 데이터가 적절히 정렬되어 있기 때문에 쿼리가 효율적으로 동작한다. 

이번에는 age를 이용한 범위 쿼리를 작성했다고 해보자.

```js
> db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})
```

이 경우 인덱스의 첫번째 키인 age를 이용해 적절한 데이터 목록을 찾아서 반환받는다.  
데이터 조회시 인덱스를 사용하므로 인덱스 순서에 따라 도큐먼트를 받게 된다.

```
[21, "user100154"] -> 8623530928
[21, "user100266"] -> 8623545264
...
[21, "user999600"] -> 8765277104
[22, "user100017"] -> 8623513392
...
[29, "user999861"] -> 8765310512
[30, "user100098"] -> 8623523760
[30, "user100155"] -> 8623531056
...
```

이번에는 범위 쿼리에 대해서 username으로 정렬을 적용한 경우를 살펴보자.

```js
db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})
```

위에서 살펴봤듯이 인덱스는 `{"age" : 1, "username" : 1}`으로 정렬된 결과를 반환한다.  
쿼리에서는 username으로 정렬된 결과를 요청했으므로, 몽고DB에서는 인메모리에서 정렬을 수행하게 되어 성능이 저하된다.

이 때 만약 `{"username" : 1, "age" : 1}`으로 인덱스를 적용했다면 어떻게 동작할까?  
몽고DB에서는 원하는 결과를 얻기 위해 모든 데이터를 탐색해야 하지만, 인메모리 정렬 없이도 원하는 순서대로 정렬된 데이터를 얻게 된다.  

```
[user100000, 21] -> 8623511216
[user100003, 27] -> 8623511600
[user100004, 22] -> 8623511728
...
```

복합 인덱스 구성 시에는 이 점을 고려하여 정렬 기준 키를 첫번째 인덱스로 두는 것이 좋다.
