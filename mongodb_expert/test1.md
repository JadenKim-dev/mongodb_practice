# ✏️ 1주차 오답노트

Practive Test 후 몰랐거나 헷갈린 내용, 새롭게 공부한 내용 등을 정리합니다.

## 결과

![Alt text](./images/test1.png)

## 오답 정리

### **db.runCommand**

`db.runCommand`는 MongoDB에서 데이터베이스 수준의 명령을 실행할 때 사용되어, 다양한 시스템 명령어를 실행하거나 특정 동작을 수행하게 할 수 있습니다.  

```js
db.runCommand({ <command>: <value>, ... })
```

**예시 1: 데이터베이스 상태 확인**

MongoDB의 현재 데이터베이스 상태와 다양한 통계 정보를 확인하려면 `dbStats` 명령어를 사용할 수 있습니다.

```jsx
db.runCommand({ dbStats: 1 })
```

**예시 2: 컬렉션 생성**

새로운 컬렉션을 생성하려면 `create` 명령어를 사용할 수 있습니다.  
다음 쿼리는 최대 5000개의 문서와 5MB 크기의 용량을 가지는 `myNewCollection`이라는 컬렉션을 생성합니다.

```js
db.runCommand({
  create: "myNewCollection",
  capped: true,
  size: 5242880,
  max: 5000
})
```

**예시 3: 인덱스 생성**

특정 필드에 대해 인덱스를 생성하려면 `createIndexes` 명령을 사용할 수 있습니다.  
다음 명령어는 `myCollection` 컬렉션에서 `fieldName` 필드에 대해 오름차순 인덱스를 생성합니다.

```js
db.runCommand({
  createIndexes: "myCollection",
  indexes: [
    {
      key: { "fieldName": 1 },
      name: "fieldName_1"
    }
  ]
})
```

**예시 4: 서버 상태 확인**

서버 상태에 대한 메트릭을 확인하려면 `serverStatus` 명령을 사용할 수 있습니다.

```jsx
db.runCommand({ serverStatus: 1 })
```

**예시 5: 사용자 정의 명령어 실행**

기타 사용자 정의 명령어를 실행할 수도 있습니다.  
예를 들어 현재 연결된 사용자의 세션 정보를 확인하기 위해 다음과 같이 명령할 수 있습니다.

```js
db.runCommand({ connectionStatus: 1 })
```

### 일부 쿼리 조건에 인덱스 적용

예를 들어 `{ title: 1 }` 인덱스가 생성되었다고 하자.  
이 때 다음의 쿼리에도 인덱스를 적용할 수 있다.

```js
    db.movies.find( { genres: "Drama" } ).sort( { title: 1 } ) // 정렬 조건에 적용
```

### rs.add 명령어

MongoDB의 Replica Set에서 `rs.add()` 명령은 기존의 Replica Set에 새로운 멤버(secondary 노드)를 추가하는 데 사용됩니다.  
Replica Set은 MongoDB의 고가용성과 데이터 중복성을 보장하는 기능으로, 여러 개의 MongoDB 인스턴스가 하나의 데이터베이스를 복제하여 동일한 데이터를 유지합니다.

```jsx
rs.add("<hostname>:<port>")
```

- `<hostname>`: 추가하려는 MongoDB 인스턴스가 실행 중인 서버의 호스트 이름 또는 IP 주소.
- `<port>`: 추가하려는 MongoDB 인스턴스가 리스닝하고 있는 포트 번호.

예를 들어, `rs.add("mongo-node2:27017")`는 `mongo-node2`라는 호스트에서 27017 포트로 리스닝 중인 MongoDB 인스턴스를 Replica Set에 추가하는 명령입니다.

1. **사용 시점**:
    
    `rs.add()`는 **Primary 노드**에서만 실행할 수 있습니다.  
    Primary 노드는 Replica Set에서 쓰기 작업을 담당하는 노드입니다.  
    
    새로운 멤버는 기본적으로 Secondary 노드로 추가됩니다.  
    Secondary 노드는 Primary 노드의 데이터를 복제하여 유지합니다.
    
2. **구성 옵션**:
    
    `rs.add()` 명령은 여러 가지 옵션을 포함할 수 있습니다.  
    예를 들어, 새로운 멤버를 숨겨진(hidden) 노드로 추가하거나, 특정 우선순위(priority)를 부여하는 등 다양한 설정이 가능합니다.
    
    다음 명령은 `mongo-node2:27017`을 숨겨진(hidden) 노드로 추가하며, 이 노드는 자동 선출에서 Primary로 승격되지 않도록 우선순위를 `0`으로 설정합니다.
    
    ```jsx
    rs.add({
      host: "mongo-node2:27017",
      priority: 0,
      hidden: true
    })
    ```
    
3. **검증 및 적용**:
    
    `rs.add()` 명령을 실행하면, MongoDB는 자동으로 새로운 노드에 연결하고, 데이터를 복제하기 시작합니다.  
    
    추가된 멤버의 상태는 `rs.status()` 명령을 통해 확인할 수 있습니다.
    
4. **주의사항**:
    
    새로 추가된 멤버가 정상적으로 동기화되지 않으면, Replica Set의 데이터 일관성이 위험에 처할 수 있습니다.  
    따라서 추가된 멤버의 초기화와 동기화 과정에서 장애가 없는지 주의 깊게 모니터링해야 합니다.
    

**ReplicaSet hidden member**

몽고디비(MongoDB)의 레플리카셋에서 "히든(hidden)" 멤버는 일반적인 레플리카셋 멤버와 비슷하게 데이터를 복제하지만, 클라이언트 애플리케이션이 직접 접근할 수 없도록 설정된 특별한 멤버입니다. 

1. **클라이언트 접근 차단**: 히든 멤버는 클라이언트 애플리케이션에서 `readPreference`로 접근할 수 없습니다. 클라이언트는 히든 멤버로 직접 쿼리를 보내거나 그 멤버를 읽기 위한 멤버로 사용할 수 없습니다.
2. **선거 참여 불가**: 히든 멤버는 선거에 참여하지 않습니다. 이는 이 멤버가 주요 데이터베이스 역할을 맡지 않도록 보장합니다. 즉, 프라이머리(primary)로 승격되지 않습니다.
3. **전용 작업**: 히든 멤버는 백업, 분석 등과 같은 특정 작업에 사용될 수 있습니다. 예를 들어, 운영에 영향을 미치지 않고 데이터 분석 작업을 수행하려는 경우 히든 멤버를 사용하여 운영 환경에 부담을 주지 않도록 할 수 있습니다.
4. **구성 예시**: 히든 멤버를 설정할 때는 `priority` 값을 0으로 설정하여 프라이머리로 승격되지 않도록 하고, `hidden` 필드를 `true`로 설정하여 클라이언트 접근을 차단합니다.
    
    ```json
    {
      "_id": 2,
      "host": "example.com:27019",
      "priority": 0,
      "hidden": true
    }
    
    ```
    

**ReplicaSet의 priority 필드**

MongoDB의 레플리카셋에서 `priority` 필드는 특정 멤버가 **프라이머리(primary)** 역할을 수행할 가능성을 제어하는 데 사용됩니다.  
이 값은 레플리카셋 멤버 간의 상대적 중요도를 나타내며, 값이 클수록 해당 멤버가 프라이머리로 승격될 가능성이 높아집니다.

### `priority` 값의 설정 및 의미:

1. **기본 값 (1)**:
    
    레플리카셋의 모든 멤버는 기본적으로 `priority` 값이 1로 설정됩니다.  
    이는 해당 멤버가 다른 멤버와 동일한 우선순위로 프라이머리로 선출될 수 있음을 의미합니다.
    
2. **높은 값 (예: 2, 3, …)**:
    
    `priority` 값을 1보다 높게 설정하면, 해당 멤버가 프라이머리로 선출될 가능성이 더 높아집니다.  
    예를 들어, `priority`가 2로 설정된 멤버는 `priority`가 1로 설정된 멤버보다 프라이머리로 선출될 우선순위가 높습니다.
    이 옵션은 특정 데이터 센터나 서버가 다른 멤버보다 더 신뢰성이 높다고 판단될 때 유용합니다.
    
3. **낮은 값 (예: 0.5, 0.1)**:
    
    `priority` 값을 1보다 낮게 설정하면, 해당 멤버가 프라이머리로 선출될 가능성이 줄어듭니다.  
    이는 특정 멤버가 프라이머리로 선택되지 않도록 우선순위를 낮추고자 할 때 사용됩니다.
    
4. **0으로 설정**:
    
    `priority` 값을 0으로 설정하면, 해당 멤버는 절대로 프라이머리로 승격되지 않습니다.
    이 설정은 주로 **세컨더리(secondary)** 역할만 수행하도록 하거나, **히든(hidden)** 멤버와 같이 특정 작업(백업, 분석 등)을 위해 프라이머리로 선택되지 않도록 할 때 사용됩니다.

### MongoDB 인덱스 필드 순서

```js
// 문제 쿼리
db.employees.find({
   "hire_date": {
      "$gte": ISODate("2022-01-01T00:00:00.000Z")
   },
   "department": "Sales",
   "performance_rating": 4
})

// 적절한 인덱스
{ hire_date: 1, department: 1, performance_rating: 1 }
```

MongoDB는 인덱스의 왼쪽에서부터 순서대로 인덱스를 사용하므로, 복합 인덱스의 필드 순서는 쿼리 조건의 필드 순서와 일치해야 합니다.  
ESR 원칙은 쿼리의 효율성을 위해 권장되는 규칙인 것이지, 인덱스가 적용되는 순서를 규정하지는 않습니다.

### ESR 원칙

MongoDB에서 쿼리의 필터 조건을 구성할 때, **ESR** 순서(Equality, Sort, Range)로 구성하면 쿼리 성능을 최적화하고 인덱스를 효율적으로 활용할 수 있습니다.  
이 순서는 필터링 과정에서 인덱스를 최대한 활용할 수 있도록 돕습니다.

#### ESR 순서의 의미:

1. **Equality (동등 조건)**:
    
    동등 조건은 `field = value`와 같은 조건입니다. 
    동등 조건을 쿼리에서 먼저 적용하면, 데이터의 범위를 크게 줄일 수 있어 이후의 필터링이나 정렬 작업이 더 빠르게 수행될 수 있습니다.
    
2. **Sort (정렬 조건)**:
    
    정렬 조건은 쿼리 결과를 특정 필드를 기준으로 정렬할 때 사용됩니다.
    동등 조건으로 필터링한 데이터에 정렬을 적용할 때, 인덱스를 활용하면 정렬 작업이 매우 효율적이 됩니다. 
    이미 동등 조건으로 필터링된 데이터에 대해 정렬이 이루어지므로, 필요한 정렬 작업이 최소화됩니다.
    
3. **Range (범위 조건)**:
    
    범위 조건은 `>, <, >=, <=`와 같은 연산자를 사용하는 조건입니다.
    범위 조건은 필터링할 데이터의 범위를 추가로 좁히기 위해 사용됩니다. 
    그러나 인덱스의 특성상, 범위 조건 이후의 다른 조건들은 인덱스를 효율적으로 사용할 수 없게 될 수 있습니다.  
    그래서 범위 조건은 동등 조건과 정렬 조건 이후에 적용하는 것이 좋습니다.
    

#### 왜 ESR 순서가 중요한가?

- **인덱스 효율성**: MongoDB에서 인덱스는 왼쪽부터 순차적으로 사용됩니다. ESR 순서로 조건을 구성하면, 인덱스의 모든 필드를 최대한 활용할 수 있게 됩니다.
- **성능 최적화**: 동등 조건을 먼저 적용하여 데이터의 범위를 좁히고, 그 후에 정렬 조건을 적용하여 이미 필터링된 데이터에 정렬을 효율적으로 수행하며, 마지막으로 범위 조건을 적용해 필요한 데이터만 추출하게 됩니다. 이렇게 하면 쿼리 성능이 크게 향상됩니다.
- **일관된 결과**: 이 순서를 따르면, 동일한 쿼리가 반복될 때마다 일관된 성능과 결과를 얻을 수 있습니다.

위 예제의 경우 인덱스와 쿼리를 다음과 같이 구성하여 보다 효율적으로 쿼리할 수 있다.

### `BulkWrite` 사용법

MongoDB 에서는 `bulkWrite()` 메서드를 사용하여 여러 개의 문서 작업(삽입, 업데이트, 삭제 등)을 한 번에 수행할 수 있습니다.  
이 메서드는 각 작업이 명시된 객체들로 구성된 배열을 매개변수로 받습니다.

기본적인 구조는 다음과 같습니다:

```jsx
db.collection.bulkWrite([
    { insertOne: { "document": { /* document fields */ } } },
    { updateOne: { "filter": { /* query */ }, "update": { /* update operations */ } } },
    { deleteOne: { "filter": { /* query */ } } },
    { replaceOne: { "filter": { /* query */ }, "replacement": { /* new document */ } } }
])
```

### 2. 예제

다음은 `users` 컬렉션에 대해 여러 작업을 수행하는 예제입니다:

```jsx
db.users.bulkWrite([
    // 1. 문서 삽입
    { insertOne: { "document": { "_id": 1, "name": "Alice", "age": 25 } } },
    { insertOne: { "document": { "_id": 2, "name": "Bob", "age": 30 } } },

    // 2. 문서 업데이트
    { updateOne: { "filter": { "_id": 1 }, "update": { "$set": { "age": 26 } } } },

    // 3. 문서 교체
    { replaceOne: { "filter": { "_id": 2 }, "replacement": { "_id": 2, "name": "Robert", "age": 31 } } },

    // 4. 문서 삭제
    { deleteOne: { "filter": { "_id": 1 } } }
])
```

- **`insertOne`**: 새 문서를 컬렉션에 삽입합니다.
- **`updateOne`**: 조건에 맞는 첫 번째 문서를 업데이트합니다.
- **`replaceOne`**: 조건에 맞는 문서를 완전히 다른 문서로 교체합니다.
- **`deleteOne`**: 조건에 맞는 첫 번째 문서를 삭제합니다.

`bulkWrite()` 메서드는 수행된 작업에 대한 요약 정보를 반환합니다.  
작업이 성공했는지, 몇 개의 문서가 영향을 받았는지 등을 확인할 수 있습니다.

```json
{
    "insertedCount" : 2,
    "matchedCount" : 2,
    "modifiedCount" : 2,
    "deletedCount" : 1,
    "upsertedCount" : 0,
    "upsertedIds" : { },
    "insertedIds" : { "0" : 1, "1" : 2 }
}
```

### $slice 연산자

`$slice` 연산자는 MongoDB에서 배열의 일부 요소를 선택하는 데 사용됩니다.  
`$slice` 연산자는 일반적으로 배열 필드에 적용되며, 원하는 개수만큼 배열의 처음 또는 끝에서 요소를 선택할 수 있습니다.

```ts
{ field: { $slice: count } }
{ field: { $slice: [skip, limit] } }
```

```ts
// 배열의 처음 n개의 요소를 선택
db.collection.find(
   { },
   { fieldName: { $slice: 3 } }
)

// 배열의 마지막 n개의 요소를 선택
db.collection.find(
   { },
   { fieldName: { $slice: -3 } }
)

// 배열의 중간에서 요소 선택 (인덱스 2부터 시작해서 3개의 요소 선택)
db.collection.find(
   { },
   { fieldName: { $slice: [2, 3] } }
)
```

### MongoDB 드라이버의 추상화 수준

MongoDB 드라이버는 MongoDB와 작업하기 위한 편리한 인터페이스를 제공하지만, 기본적인 데이터베이스 구조를 완전히 추상화하지는 않습니다.  
개발자는 여전히 MongoDB의 데이터 모델과 쿼리 언어에 대한 기본적인 이해가 필요합니다.
